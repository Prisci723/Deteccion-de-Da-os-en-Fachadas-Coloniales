# -*- coding: utf-8 -*-
"""DiagnosticoLangchain.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1ISgrnU4FUXvHhxMSBUgewWC1ETjd6_vS
"""


# Importaciones necesarias
import os
from langchain.document_loaders import PyPDFLoader
from langchain.text_splitter import RecursiveCharacterTextSplitter
from langchain.vectorstores import FAISS
from langchain_community.document_loaders import PyPDFLoader
from langchain_community.embeddings import HuggingFaceEmbeddings
from langchain_openai import ChatOpenAI
from langchain.chains import LLMChain
from langchain.prompts import ChatPromptTemplate
from dotenv import load_dotenv
load_dotenv()


# 1. Carga del PDF de referencia con información sobre diagnósticos de fachadas
def cargar_pdf_referencia(ruta_pdf):
    """Carga un PDF con información de referencia sobre diagnósticos de fachadas"""
    print(f"Cargando PDF de referencia desde: {ruta_pdf}")
    loader = PyPDFLoader(ruta_pdf)
    documentos = loader.load()
    return documentos

# 2. Procesar los documentos y crear una base de conocimiento vectorial
def crear_base_conocimiento(documentos):
    """Procesa los documentos y crea una base de conocimiento vectorial para consultas"""
    # Dividir los documentos en chunks manejables
    text_splitter = RecursiveCharacterTextSplitter(
        chunk_size=1000,
        chunk_overlap=200,
        separators=["\n\n", "\n", " ", ""]
    )
    chunks = text_splitter.split_documents(documentos)

    # Crear embeddings y base de conocimiento vectorial
    embeddings = HuggingFaceEmbeddings(model_name="sentence-transformers/paraphrase-multilingual-mpnet-base-v2")
    vectorstore = FAISS.from_documents(chunks, embeddings)

    print(f"Base de conocimiento creada con {len(chunks)} fragmentos.")
    return vectorstore

# 3. Definir la plantilla de prompt para el diagnóstico
def crear_plantilla_prompt():
    """Crea la plantilla de prompt para el diagnóstico de daños"""
    plantilla = """
    Eres un experto restaurador y arquitecto especializado en edificios coloniales de Sucre, Bolivia,
    declarada Patrimonio Cultural de la Humanidad por la UNESCO.

    Debes analizar los siguientes datos cuantitativos sobre daños detectados en un edificio colonial
    y proporcionar un diagnóstico detallado y recomendaciones de conservación.

    DATOS DEL ANÁLISIS:
    {resultados_analisis}

    INFORMACIÓN CONTEXTUAL:
    - El edificio se encuentra en {ubicacion_exacta}, Sucre, Bolivia.
    - Época de construcción aproximada: {epoca_construccion}.
    - Uso actual: {uso_actual}.
    - Última intervención conocida: {ultima_intervencion}.
    * Deformación: Revestimiento de piedra en bases de muros. Alteraciones en el revestimiento pétreo que pierde su uniformidad original. Abultamientos, irregularidades, pérdida de planeidad en superficies que deberían ser uniformes
    * Desprendimiento: Revoque de muros. Separación o caída del material de revoque de la superficie del muro.Ausencia parcial o total del recubrimiento, exposición del material base.
    * Deterioro: Elementos de madera (puertas y ventanas).Desgaste progresivo del material maderero.Pérdida de propiedades mecánicas, cambios dimensionales, degradación superficial
    * Ensanchamiento: Paredes y bases de muros. Aumento progresivo del espesor de los elementos estructurales. Incremento dimensional que afecta la geometría original del elemento
    * Filtración: Muros (superficie exterior). Ingreso de agua a través de deficiencias en la protección del techo. Manchas de barro, escurrimientos verticales, marcas de humedad descendente.
    * Fisuración: Muros (superficie). Aparición de fracturas superficiales en forma de patrones geométricos. Líneas irregulares entrecruzadas, formas poligonales, red de microfracturas.
    * Grietas: Muros. Fracturas que atraviesan el espesor del elemento estructural. Aberturas lineales de mayor profundidad que las fisuras
    * Humedad: Muros y bases. Presencia de sales eflorescentes y oscurecimiento por absorción de agua. Manchas blanquecinas (eflorescencias), zonas oscurecidas, cambios de coloración.
    * Humedad Interna: Superficie de muros. Deterioro del revoque por acción de humedad desde el interior. Porosidad del revoque, perforaciones uniformes, abultamientos agrupados 15.
    * Hundimiento: Techos (tejas). Deformación descendente de la cubierta. Pérdida de horizontalidad, combadura hacia abajo, desplazamiento de tejas 15,

    CONTEXTO REGIONAL:
    Sucre tiene un clima templado con una temporada de lluvias entre noviembre y marzo.
    Los edificios coloniales de Sucre suelen ser construidos con adobe, piedra caliza y techos de tejas.
    La ciudad está en una zona sísmica moderada.

    CONOCIMIENTO RELEVANTE:
    {contexto_adicional}

    Por favor, proporciona:

    1. DIAGNÓSTICO GENERAL: Interpretación global del estado del edificio basada en los porcentajes de daños.

    2. ANÁLISIS POR ELEMENTO: Evalúa cada elemento arquitectónico (base_muro, muro, techo, espadaña, abertura(puertas, ventanas y balcones)) y la gravedad de sus daños.

    3. CAUSAS PROBABLES: Identifica las posibles causas de los daños detectados (factores climáticos, estructurales, etc.).

    4. RECOMENDACIONES DE INTERVENCIÓN: Sugiere acciones concretas de restauración y conservación, priorizadas por urgencia.

    5. NIVEL DE URGENCIA: Clasifica el nivel general de urgencia de intervención (bajo, medio, alto, crítico).

    Tu diagnóstico debe ser preciso, basado en los datos proporcionados y el conocimiento específico sobre arquitectura colonial de Sucre.
    Y el formato de salida debe ser similar al de un documento técnico.
    """

    return ChatPromptTemplate.from_template(plantilla)

# 4. Función para obtener información contextual relevante
def obtener_contexto_relevante(vectorstore, resultados_analisis, elementos_arquitectonicos):
    """Obtiene información contextual relevante de la base de conocimiento"""
    # Construir una consulta basada en los elementos arquitectónicos y sus daños
    consulta = f"Información sobre daños en {', '.join(elementos_arquitectonicos)} "
    consulta += f"incluyendo {', '.join([d for d in ['desprendimiento', 'humedad', 'deterioro', 'hundimiento', 'ensanchamiento', 'filtracion', 'grietas', 'humedad_interna', 'deformacion', 'fisuracion'] if d in resultados_analisis.lower()])}"

    # Recuperar documentos relevantes
    documentos_relevantes = vectorstore.similarity_search(consulta, k=3)
    contexto = "\n\n".join([doc.page_content for doc in documentos_relevantes])

    return contexto

# 5. Crear la cadena de diagnóstico
def crear_cadena_diagnostico(llm):
    """Crea la cadena LLM para generar diagnósticos"""
    prompt_template = crear_plantilla_prompt()
    chain = LLMChain(llm=llm, prompt=prompt_template)
    return chain

def generar_diagnostico(resultados_analisis, ubicacion_exacta, epoca_construccion,
                       uso_actual, ultima_intervencion, vectorstore, llm, temperatura=0.3):
    """Genera un diagnóstico completo basado en los resultados del análisis"""

    # Extraer elementos arquitectónicos de los resultados
    elementos_arquitectonicos = []
    for linea in resultados_analisis.split('\n'):
        if 'ELEMENTO:' in linea:
            elementos_arquitectonicos.append(linea.split('ELEMENTO:')[1].strip().split(' ')[0])

    # Obtener contexto relevante
    contexto_adicional = obtener_contexto_relevante(vectorstore, resultados_analisis, elementos_arquitectonicos)

    # Configurar LLM con temperatura apropiada para diagnósticos técnicos
    if hasattr(llm, 'temperature'):
        llm.temperature = temperatura

    # Crear y ejecutar la cadena
    cadena = crear_cadena_diagnostico(llm)
    # Updated this call to use ChatCompletion.create
    # Ref: https://github.com/hwchase17/langchain/blob/v0.0.248/langchain/chat_models/openai.py#L140
    # Ref: https://platform.openai.com/docs/api-reference/chat/create
    respuesta = cadena.run({
        "resultados_analisis": resultados_analisis,
        "ubicacion_exacta": ubicacion_exacta,
        "epoca_construccion": epoca_construccion,
        "uso_actual": uso_actual,
        "ultima_intervencion": ultima_intervencion,
        "contexto_adicional": contexto_adicional
    })

    return respuesta

# Configurar API key para el LLM (ajusta tsegún el proveedor que uses)
os.environ["OPENAI_API_KEY"] = os.getenv("OPENAI_API_KEY")
    # Cargar PDF de referencia
ruta_pdf = r"Completo_160625_compressed.pdf"  # Ajusta la ruta según tu estructura
documentos = cargar_pdf_referencia(ruta_pdf)

    # Crear base de conocimiento
vectorstore = crear_base_conocimiento(documentos)

    # Configurar el LLM (OpenAI como ejemplo, puedes usar otros)
llm = ChatOpenAI(model_name="gpt-3.5", temperature=0.3)

